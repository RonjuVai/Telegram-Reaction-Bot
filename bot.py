import os
import random
import time
import requests
import logging
from threading import Thread
from datetime import datetime

print("ü§ñ ‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø-‡¶¨‡¶ü ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶ï‡¶∂‡¶® ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ - Railway ‡¶≠‡¶æ‡¶∞‡ßç‡¶∏‡¶®")
print("üöÄ 24/7 Running on Railway")

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('multi_bot.log')
    ]
)
logger = logging.getLogger(__name__)

# Environment variable ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡¶ü ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶®‡¶ø‡¶®
BOT_TOKENS_STR = os.environ.get("BOT_TOKENS", "")

if not BOT_TOKENS_STR:
    print("‚ùå BOT_TOKENS environment variable ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á!")
    print("üìù Railway Dashboard ‚Üí Variables ‚Üí BOT_TOKENS")
    exit(1)

# ‡¶ü‡ßã‡¶ï‡ßá‡¶®‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®
BOT_TOKENS = [token.strip() for token in BOT_TOKENS_STR.split(",") if token.strip()]

if not BOT_TOKENS:
    print("‚ùå ‡¶ï‡ßã‡¶®‡ßã valid ‡¶¨‡¶ü ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø!")
    exit(1)

print(f"üì¶ {len(BOT_TOKENS)}‡¶ü‡¶ø ‡¶¨‡¶ü ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá")

# ‡¶á‡¶Æ‡ßã‡¶ú‡¶ø ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü
emojis = ["üëç", "‚ù§", "üî•", "üëè", "üòç", "üéâ", "ü§©", "üíØ", "üòÅ", "ü•∞", "‚ö°", "‚ú®", "üåü", "üí´", "üôè"]

class RailwayMultiBotSystem:
    def __init__(self, tokens):
        self.working_bots = []
        self.start_time = datetime.now()
        self.message_count = 0
        self.successful_reactions = 0
        self.last_update_id = 0  # ‚úÖ FIX: Initialize with 0 instead of None
        
        print("üîç ‡¶¨‡¶ü‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")
        
        # ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶¨‡¶ü ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®
        for i, token in enumerate(tokens, 1):
            if self.test_bot(token):
                bot_info = self.get_bot_info(token)
                if bot_info:
                    self.working_bots.append({
                        "token": token,
                        "base_url": f"https://api.telegram.org/bot{token}",
                        "name": bot_info.get("first_name", f"‡¶¨‡¶ü-{i}"),
                        "username": bot_info.get("username", f"bot_{i}")
                    })
                    print(f"‚úÖ ‡¶¨‡¶ü {i}: {bot_info.get('first_name', 'Unknown')} (@{bot_info.get('username', 'N/A')})")
                else:
                    print(f"‚ö†Ô∏è ‡¶¨‡¶ü {i}: ‡¶á‡¶®‡¶´‡ßã ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø")
            else:
                print(f"‚ùå ‡¶¨‡¶ü {i}: ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßá ‡¶®‡¶æ")
        
        print(f"\nüîß {len(self.working_bots)}‡¶ü‡¶ø ‡¶¨‡¶ü ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá")
        
        if len(self.working_bots) == 0:
            print("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶¨‡¶ü ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßá ‡¶®‡¶æ! ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®")
            return
        
        # ‡¶∏‡¶¨ ‡¶¨‡¶ü‡ßá‡¶∞ webhook ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®
        self.delete_all_webhooks()
        
        # Start monitoring thread
        self.monitor_thread = Thread(target=self.monitor_system, daemon=True)
        self.monitor_thread.start()
    
    def test_bot(self, token):
        """‡¶¨‡¶ü‡¶ü‡¶ø ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®"""
        try:
            url = f"https://api.telegram.org/bot{token}/getMe"
            response = requests.get(url, timeout=10)
            result = response.json()
            return result.get('ok', False)
        except Exception as e:
            logger.error(f"Bot test failed: {e}")
            return False
    
    def get_bot_info(self, token):
        """‡¶¨‡¶ü‡ßá‡¶∞ ‡¶§‡¶•‡ßç‡¶Ø ‡¶®‡¶ø‡¶®"""
        try:
            url = f"https://api.telegram.org/bot{token}/getMe"
            response = requests.get(url, timeout=10)
            result = response.json()
            return result.get('result', {}) if result.get('ok') else {}
        except:
            return {}
    
    def delete_all_webhooks(self):
        """‡¶∏‡¶¨ ‡¶¨‡¶ü‡ßá‡¶∞ webhook ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®"""
        for bot in self.working_bots:
            try:
                requests.get(f"{bot['base_url']}/deleteWebhook", timeout=5)
            except:
                pass
        print("‚úÖ ‡¶∏‡¶¨ ‡¶¨‡¶ü‡ßá‡¶∞ ‡¶ì‡¶Ø‡¶º‡ßá‡¶¨‡¶π‡ßÅ‡¶ï ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá")
    
    def send_reaction(self, bot, chat_id, message_id, emoji):
        """‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶ü ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶ï‡¶∂‡¶® ‡¶¶‡¶ø‡¶®"""
        url = f"{bot['base_url']}/setMessageReaction"
        
        payload = {
            "chat_id": chat_id,
            "message_id": message_id,
            "reaction": [{"type": "emoji", "emoji": emoji}]
        }
        
        try:
            response = requests.post(url, json=payload, timeout=10)
            result = response.json()
            
            if result.get('ok'):
                return True
            else:
                error = result.get('description', 'Unknown error')
                if "CHAT_ADMIN_REQUIRED" in error:
                    logger.warning(f"{bot['name']}: ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶™‡¶æ‡¶∞‡¶Æ‡¶ø‡¶∂‡¶® ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®")
                elif "bot is not a member" in error.lower():
                    logger.warning(f"{bot['name']}: ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡ßá ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶° ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á")
                elif "REACTION_INVALID" in error:
                    logger.warning(f"{bot['name']}: ‡¶á‡¶Æ‡ßã‡¶ú‡¶ø ‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ")
                return False
                
        except Exception as e:
            logger.error(f"{bot['name']} ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶è‡¶∞‡¶∞: {e}")
            return False
    
    def send_multiple_reactions(self, chat_id, message_id, num_reactions=None):
        """‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶¨‡¶ü ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá multiple reactions ‡¶¶‡¶ø‡¶®"""
        if len(self.working_bots) == 0:
            logger.error("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶ï‡¶æ‡¶ú‡¶ï‡¶∞‡¶æ ‡¶¨‡¶ü ‡¶®‡ßá‡¶á!")
            return 0
            
        if num_reactions is None:
            num_reactions = min(len(self.working_bots), 10)  # Max 10 reactions
        
        available_bots = random.sample(self.working_bots, min(num_reactions, len(self.working_bots)))
        
        logger.info(f"üéØ {len(available_bots)}‡¶ü‡¶ø ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶ï‡¶∂‡¶® ‡¶¶‡¶ø‡¶ö‡ßç‡¶õ‡¶ø...")
        
        success_count = 0
        
        for i, bot in enumerate(available_bots, 1):
            emoji = random.choice(emojis)
            success = self.send_reaction(bot, chat_id, message_id, emoji)
            
            if success:
                success_count += 1
                self.successful_reactions += 1
                logger.info(f"ü§ñ {bot['name']}: {emoji} ‚úÖ")
            else:
                logger.warning(f"ü§ñ {bot['name']}: {emoji} ‚ùå")
            
            time.sleep(random.uniform(0.5, 2))  # Random delay to avoid rate limit
        
        logger.info(f"üéä {success_count}‡¶ü‡¶ø ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶ï‡¶∂‡¶® ‡¶∏‡¶´‡¶≤!")
        return success_count
    
    def get_updates_from_main_bot(self):
        """‡¶™‡ßç‡¶∞‡¶ß‡¶æ‡¶® ‡¶¨‡¶ü ‡¶•‡ßá‡¶ï‡ßá ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶™‡¶æ‡¶®"""
        if len(self.working_bots) == 0:
            return None
            
        main_bot = self.working_bots[0]
        url = f"{main_bot['base_url']}/getUpdates"
        
        try:
            # ‚úÖ FIX: Proper offset handling
            params = {
                "timeout": 30, 
                "allowed_updates": ["message"],
                "offset": self.last_update_id + 1  # ‚úÖ Now this will always work
            }
            
            response = requests.get(url, params=params, timeout=35)
            return response.json()
        except Exception as e:
            logger.error(f"Update error: {e}")
            return None
    
    def monitor_system(self):
        """‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶Æ‡¶®‡¶ø‡¶ü‡¶∞‡¶ø‡¶Ç"""
        while True:
            try:
                uptime = datetime.now() - self.start_time
                hours = uptime.total_seconds() // 3600
                minutes = (uptime.total_seconds() % 3600) // 60
                
                status_msg = f"""
üìä **System Status - Railway**
‚è∞ Uptime: {int(hours)}h {int(minutes)}m
ü§ñ Working Bots: {len(self.working_bots)}
üì® Messages Processed: {self.message_count}
‚úÖ Successful Reactions: {self.successful_reactions}
üü¢ Status: ACTIVE
                """
                print(status_msg)
                logger.info(f"Status: {len(self.working_bots)} bots, {self.message_count} msgs, {self.successful_reactions} reactions")
                
            except Exception as e:
                logger.error(f"Monitor error: {e}")
            
            time.sleep(300)  # 5 minutes
    
    def manual_reaction(self, chat_id, message_id, num_reactions=5):
        """‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡¶Ø‡¶º‡¶æ‡¶≤‡¶ø ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶ï‡¶∂‡¶® ‡¶™‡¶æ‡¶†‡¶æ‡¶®"""
        logger.info(f"üîß Manual reaction: chat={chat_id}, msg={message_id}, count={num_reactions}")
        return self.send_multiple_reactions(chat_id, message_id, num_reactions)
    
    def run_polling(self):
        """‡¶™‡ßã‡¶≤‡¶ø‡¶Ç ‡¶Æ‡ßã‡¶°‡ßá ‡¶ö‡¶≤‡ßÅ‡¶®"""
        if len(self.working_bots) == 0:
            logger.error("‚ùå ‡¶ï‡ßã‡¶®‡ßã ‡¶ï‡¶æ‡¶ú‡¶ï‡¶∞‡¶æ ‡¶¨‡¶ü ‡¶®‡ßá‡¶á!")
            print("\nüîß ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø:")
            print("1. Railway Dashboard ‚Üí Variables ‚Üí BOT_TOKENS ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®")
            print("2. ‡¶¨‡¶ü ‡¶ü‡ßã‡¶ï‡ßá‡¶®‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∏‡¶†‡¶ø‡¶ï ‡¶ï‡¶ø‡¶®‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®")
            print("3. ‡¶∏‡¶¨ ‡¶¨‡¶ü‡¶ï‡ßá ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡ßá ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶° ‡¶ï‡¶∞‡ßÅ‡¶®")
            print("4. ‡¶∏‡¶¨ ‡¶¨‡¶ü‡¶ï‡ßá ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®") 
            print("5. 'Add reactions' ‡¶™‡¶æ‡¶∞‡¶Æ‡¶ø‡¶∂‡¶® ‡¶¶‡¶ø‡¶®")
            return
        
        print(f"\nüöÄ ‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø-‡¶¨‡¶ü ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!")
        print(f"üì± {len(self.working_bots)}‡¶ü‡¶ø ‡¶¨‡¶ü ‡¶∞‡ßá‡¶°‡¶ø")
        print("‚è∞ 24/7 Railway Server ‡¶è ‡¶ö‡¶≤‡¶õ‡ßá")
        print("üí¨ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡ßá ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶™‡¶æ‡¶†‡¶æ‡¶®...")
        print("üìä ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏ ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡ß´ ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶¨‡ßá\n")
        
        try:
            while True:
                # ‡¶®‡¶§‡ßÅ‡¶® ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®
                updates_result = self.get_updates_from_main_bot()
                
                if updates_result and updates_result.get("ok"):
                    updates = updates_result.get("result", [])
                    
                    for update in updates:
                        update_id = update["update_id"]
                        
                        # ‚úÖ FIX: Always update last_update_id
                        if update_id > self.last_update_id:
                            self.last_update_id = update_id
                        
                        if "message" in update:
                            message = update["message"]
                            # ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡ßÅ‡¶®
                            if message.get("chat", {}).get("type") in ["group", "supergroup"]:
                                chat_id = message["chat"]["id"]
                                message_id = message["message_id"]
                                user_name = message.get("from", {}).get("first_name", "Unknown")
                                text = message.get("text", "")
                                
                                # ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®
                                if text and text.startswith("/reaction"):
                                    # Manual reaction command
                                    parts = text.split()
                                    if len(parts) >= 4:
                                        try:
                                            target_chat_id = int(parts[1])
                                            target_message_id = int(parts[2])
                                            reaction_count = int(parts[3]) if len(parts) > 3 else 5
                                            
                                            success = self.manual_reaction(target_chat_id, target_message_id, reaction_count)
                                            logger.info(f"Manual reaction completed: {success} reactions")
                                        except ValueError:
                                            logger.error("Invalid manual reaction format")
                                    continue
                                
                                logger.info(f"üì® ‡¶®‡¶§‡ßÅ‡¶® ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú: {user_name} in chat {chat_id}")
                                
                                # ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶ï‡¶∂‡¶® ‡¶¶‡¶ø‡¶® (only if not a command)
                                if not text.startswith('/'):
                                    success = self.send_multiple_reactions(chat_id, message_id)
                                    self.message_count += 1
                                    logger.info(f"üìä ‡¶Æ‡ßã‡¶ü ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú: {self.message_count}, ‡¶∏‡¶´‡¶≤ ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶ï‡¶∂‡¶®: {success}")
                
                time.sleep(2)
                
        except KeyboardInterrupt:
            logger.info(f"üõë ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶¨‡¶®‡ßç‡¶ß! ‡¶Æ‡ßã‡¶ü {self.message_count} ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá")
        except Exception as e:
            logger.error(f"üí• ‡¶Æ‡ßá‡¶á‡¶® ‡¶≤‡ßÅ‡¶™ ‡¶è‡¶∞‡¶∞: {e}")
            print("üîÑ ‡ßß‡ß¶ ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶™‡¶∞‡ßá ‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü ‡¶π‡¶¨‡ßá...")
            time.sleep(10)
            self.run_polling()  # Auto-restart

# ‡¶Æ‡ßá‡¶á‡¶® ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ
if __name__ == "__main__":
    # Railway-specific settings
    print("=" * 50)
    print("ü§ñ MULTI-BOT REACTION SYSTEM")
    print("üöÄ DEPLOYED ON RAILWAY")
    print("=" * 50)
    
    system = RailwayMultiBotSystem(BOT_TOKENS)
    system.run_polling()